#include <ctype.h>
#include <dirent.h>
#include <float.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#define BUFFER_SIZE 256
const char *DEFAULT_SEPARATORS = " ,";
typedef enum {TYPE_T_NONE = 0,TYPE_T_BOOLEAN,TYPE_T_STRING,TYPE_T_REAL,TYPE_T_INTEGER,TYPE_T_FILEPTR,TYPE_T_FILE_LIST,N_TYPE_T} type_t;
typedef struct TexlerObject TexlerObject;
struct TexlerObject {union {bool boolean;struct {char *string;size_t length;};double real;long integer;struct {FILE *stream;fpos_t pos;char *separators;char **path_list;size_t n_line;size_t n_files;unsigned next_open_file;} file;} value;type_t type;};void free_texlerobject(TexlerObject *tex_obj){if (tex_obj == NULL) { return; }switch (tex_obj->type) {case TYPE_T_FILEPTR:if (tex_obj->value.file.stream != NULL &&tex_obj->value.file.stream != stdout &&tex_obj->value.file.stream != stderr &&tex_obj->value.file.stream != stdin){fclose(tex_obj->value.file.stream);}break;case TYPE_T_FILE_LIST:if (tex_obj->value.file.path_list != NULL){while (tex_obj->value.file.n_files > 0) {if (tex_obj->value.file.path_list[tex_obj->value.file.n_files - 1]!= NULL){free(tex_obj->value.file.path_list[tex_obj->value.file.n_files -1]);}tex_obj->value.file.n_files--;}free(tex_obj->value.file.path_list);}if (tex_obj->value.file.separators != NULL&&tex_obj->value.file.separators != DEFAULT_SEPARATORS){free(tex_obj->value.file.separators);}break;case TYPE_T_STRING:if (tex_obj->value.string != NULL){free(tex_obj->value.string);}break;case TYPE_T_BOOLEAN: /* Fallsthrough */case TYPE_T_REAL:case TYPE_T_INTEGER:break;default:break;}free(tex_obj);}bool open_file(const char *name, const char *mode,TexlerObject *tex_obj, const char *separators);void copy_buffer_content(char *from, FILE *to);void copy_file_content(FILE *from, FILE *to);void copy_file_content_texler(TexlerObject *source,TexlerObject *destination);long get_list_of_files_in_dir(char ***files, const char *path);char *string_substract(char *str1, char *str2);char *string_addition(char *str1, char *str2);bool compare_equality(TexlerObject *left, TexlerObject *right);bool compare_equality_constant_number_int(long left,TexlerObject *right);bool compare_equality_constant_string(char* left,TexlerObject *right);TexlerObject *get_next_file(TexlerObject *tex_obj, const char* separators);char *toString(TexlerObject *tex_obj);int at(char *str, long pos);typedef enum {IS_NUMBER_RETURN_NAN = 0,IS_NUMBER_RETURN_INTEGER,IS_NUMBER_RETURN_FLOATING,N_IS_NUMBER_RETURN} IS_NUMBER_RETURN;
IS_NUMBER_RETURN is_number(char *str, long int n);
long int line_length(FILE *stream, const fpos_t *pos);
long int lines(TexlerObject *tex_obj, char **buffer);
long line_by_number(TexlerObject *tex_obj,char **buffer,unsigned long n);
long int columns(char **str, char *separators, char **buffer, int *separator)
;bool is_in_string(char *str, char *line);
bool open_file(const char *name,const char *mode,TexlerObject *tex_obj,const char *separators){if (name == NULL || mode == NULL || tex_obj == NULL){return false;}size_t error_msg_len =strlen("Error while opening file ''") + strlen(name);char *error_msg = (char *)calloc(1 + error_msg_len, sizeof(char));if (error_msg == NULL) {perror("Aborting due to");exit(1);}strcpy(error_msg, "Error while opening file '");strcat(error_msg, name);strcat(error_msg, "'");FILE *fptr = fopen(name, mode);if (fptr == NULL) {perror(error_msg);free(error_msg);return false;}free(error_msg);rewind(fptr);tex_obj->type = TYPE_T_FILEPTR;tex_obj->value.file.stream = fptr;if (fgetpos(tex_obj->value.file.stream, &tex_obj->value.file.pos)){perror("Error while getting file position");return false;}tex_obj->value.file.n_line = 1;if (separators == NULL){tex_obj->value.file.separators = strdup(DEFAULT_SEPARATORS);}else{tex_obj->value.file.separators = strdup(separators);}return true;}void copy_buffer_content(char *from, FILE *to){if (from == NULL || to == NULL || (void*)from == (void*)to){return;}fputs(from, to);}void copy_file_content(FILE *from, FILE *to){if (from == NULL || to == NULL || (void*)from == (void*)to){return;}char buffer[BUFFER_SIZE] = { 0 };rewind(from);while (!feof(from)) {if (fgets(buffer, BUFFER_SIZE, from) == NULL){break;}fputs(buffer, to);}}void copy_file_content_texler(TexlerObject *source,TexlerObject *destination){if (destination->value.file.stream == stdout||strcmp(destination->value.file.separators,DEFAULT_SEPARATORS) == 0){copy_file_content(source->value.file.stream,destination->value.file.stream);}else{long source_separators_len =strlen(source->value.file.separators);long destination_separators_len =strlen(destination->value.file.separators);long line_len = BUFFER_SIZE;char *line = (char *)calloc(line_len, sizeof(char));if (line == NULL) {perror("Aborting due to");exit(1);}while (line_len > 0){line_len = lines(source, &line);if (line_len <= 0 || line == NULL) {break;}char *remaining = line;long int col_len = BUFFER_SIZE;char *column = (char *)calloc(col_len, sizeof(char));if (column == NULL) {perror("Aborting due to");exit(1);}while (remaining != NULL){int separator_char = 0;col_len =columns(&remaining,source->value.file.separators,&column,&separator_char);if (column != NULL && col_len > 0) {copy_buffer_content(column,destination->value.file.stream);}if (separator_char&&source_separators_len == destination_separators_len){for (long i = 0; i < source_separators_len; i++){if (source->value.file.separators[i] == separator_char){fputc(destination->value.file.separators[i],destination->value.file.stream);}}}else if (separator_char){fputc(destination->value.file.separators[0],destination->value.file.stream);}}free(column);}free(line);}}long get_list_of_files_in_dir(char ***files, const char *path){if (files == NULL){return -1;}char **files_list = *files;DIR *dir_ptr = NULL;struct dirent *dir = NULL;long count_files = 0;dir_ptr = opendir(path);if (dir_ptr){while ((dir = readdir(dir_ptr)) != NULL){if (dir->d_type == DT_REG){count_files++;files_list = (char **)realloc(files_list,count_files * sizeof(char *));files_list[count_files - 1] =(char *)calloc(strlen(path)+ 1+ strlen(dir->d_name)+ 1,sizeof(char));sprintf(files_list[count_files - 1],"%s/%s",path, dir->d_name);}}closedir(dir_ptr);}*files = files_list;return count_files;}/* Concat str2 at the end of str1 and store it in str1 */char *string_addition(char *str1, char *str2){if (str2 == NULL){return str1;}else if (str1 == NULL){return str2;}int str1_len = strlen(str1);int str2_len = strlen(str2);if (str1_len > 1 && str1[str1_len - 1] == '\n'){str1[str1_len - 1] = '\0';}int aux_len = 1 + str1_len + str2_len;char *aux = (char *)realloc(str1, aux_len * sizeof(char));if (aux == NULL) {perror("Aborting due to");exit(1);}strncat(aux, str2, aux_len);aux[aux_len - 1] = '\0';str1 = aux;return str1;}char *string_substract(char *str1, char *str2){int str1_len = strlen(str1);int str2_len = strlen(str2);if (str1_len < str2_len){return str1;}int i = 0;int j = str2_len;while (str2[i] == str1[str1_len - j] && str2_len > i){i++;j--;}if (str2[i] == str1[str1_len - j] && j < 1){memset(str1 + str1_len - str2_len, 0, str2_len);int aux_len = 1 + strlen(str1);char *aux = (char *)realloc(str1, aux_len * sizeof(char));if (aux == NULL) {perror("Aborting due to");exit(1);}aux[aux_len - 1] = '\0';str1 = aux;}return str1;}bool compare_equality(TexlerObject *left, TexlerObject *right){if ((left->type == TYPE_T_BOOLEAN||left->type == TYPE_T_INTEGER)&&(right->type == TYPE_T_BOOLEAN||right->type == TYPE_T_INTEGER)){return (left->value.integer - right->value.integer) == 0;}else if ((left->type == TYPE_T_REAL &&(right->type == TYPE_T_BOOLEAN ||right->type == TYPE_T_INTEGER ||right->type == TYPE_T_REAL))||(right->type == TYPE_T_REAL &&(left->type == TYPE_T_BOOLEAN ||left->type == TYPE_T_INTEGER ||left->type == TYPE_T_REAL))){return fabs(left->value.real - right->value.real) < DBL_EPSILON;}else if(left->type == TYPE_T_STRING && right->type == TYPE_T_STRING){return strcmp(left->value.string, right->value.string) == 0;}return false;}bool compare_equality_constant_number_int(long left,TexlerObject *right){if (right->type == TYPE_T_BOOLEAN||right->type == TYPE_T_INTEGER){return (left - right->value.integer) == 0;}else if (right->type == TYPE_T_REAL){return fabs((double) left - right->value.real) < DBL_EPSILON;}return false;}bool compare_equality_constant_string(char* left,TexlerObject *right){if (right->type == TYPE_T_STRING){return strcmp(left, right->value.string) == 0;}return false;}TexlerObject *get_next_file(TexlerObject *tex_obj, const char* separators){TexlerObject *input_file = NULL;if (tex_obj == NULL) {return NULL;}if (tex_obj->type == TYPE_T_FILE_LIST) {input_file = (TexlerObject *)calloc(1, sizeof(TexlerObject));if (input_file == NULL) {perror("Aborting due to");exit(1);}if (open_file(tex_obj->value.file.path_list[tex_obj->value.file.next_open_file], "r", input_file,separators) == false) {free_texlerobject(input_file);free_texlerobject(tex_obj);return NULL;}tex_obj->value.file.next_open_file++;}else if (tex_obj->type == TYPE_T_FILEPTR){input_file = tex_obj;}return input_file;}char *toString(TexlerObject *tex_obj){char *to_return = calloc(1, BUFFER_SIZE * sizeof(char *));switch (tex_obj->type) {case TYPE_T_BOOLEAN:if (tex_obj->value.boolean) {to_return = strdup("True");} else {to_return = strdup("False");}break;case TYPE_T_REAL:to_return = strdup("");sprintf(to_return, "%f", tex_obj->value.real);break;case TYPE_T_INTEGER:to_return = strdup("");sprintf(to_return, "%ld", tex_obj->value.integer);break;case TYPE_T_STRING:return tex_obj->value.string;break;default:to_return = NULL;fprintf(stderr,"\nError al querer pasar a string algo que no es una variable, solo variables de tipo numerico, ""booleanas o strings.\n");break;}return to_return;}int at(char *str, long pos){if (pos < 1 || pos > strlen(str)) {fprintf(stderr, "\nError al querer pasar un string con longitud erronea\n");return -1;} else {return str[pos - 1];}}IS_NUMBER_RETURN is_number(char *str, long int n){if (str == NULL){return IS_NUMBER_RETURN_NAN;}IS_NUMBER_RETURN ret_value = IS_NUMBER_RETURN_INTEGER;for (int i = 0; i < n; i++){int c = 0;c = str[i];if (c == '.'){ret_value = IS_NUMBER_RETURN_FLOATING;} else if (isdigit(c) == 0){ret_value = IS_NUMBER_RETURN_NAN;break;}}return ret_value;}long int line_length(FILE *stream, const fpos_t *pos){long int start = ftell(stream);long int end = 0;int c = 0;do{c = fgetc(stream);}while (c != EOF && c != '\n');end = ftell(stream);if (fsetpos(stream, pos)){perror("Error while getting file position");return false;}if (end == 0){return 0;}return end - start;}long int lines(TexlerObject *tex_obj, char **buffer){if (tex_obj == NULL || buffer == NULL || *buffer == NULL){return 0;}if (tex_obj->type != TYPE_T_FILEPTR ||tex_obj->value.file.stream == NULL){return 0;}long int new_size = 1 + line_length(tex_obj->value.file.stream,&tex_obj->value.file.pos);/* EOF reached */if (new_size == 1){return 0;}char *new_buffer = (char *)realloc(*buffer, new_size);if (new_buffer == NULL) {perror("Aborting due to");exit(1);}new_buffer[new_size - 1] = '\0';fgets(new_buffer, new_size, tex_obj->value.file.stream);if (fgetpos(tex_obj->value.file.stream, &tex_obj->value.file.pos)){perror("Error while getting file position");return false;}tex_obj->value.file.n_line++;*buffer = new_buffer;return new_size;}long line_by_number(TexlerObject *tex_obj,char **buffer,unsigned long n){if (tex_obj == NULL || buffer == NULL || *buffer == NULL){return 0;}if (tex_obj->type != TYPE_T_FILEPTR ||tex_obj->value.file.stream == NULL) {return 0;}long to_return = 0;if (tex_obj->value.file.n_line > n){rewind(tex_obj->value.file.stream);}while (tex_obj->value.file.n_line < n){to_return = lines(tex_obj, buffer);if (to_return <= 0){break;}}to_return = lines(tex_obj, buffer); /* Line n */return to_return;}long int columns(char **str, char *separators, char **buffer, int *separator){char *seps = separators;if (separators == NULL){seps = (char *)DEFAULT_SEPARATORS;}char *column_last_character = strpbrk(*str, seps);/* Value to return in *str */char *next_column = column_last_character;long int new_size = 1; /* '\0' */if (column_last_character == NULL){new_size += strlen(*str);}else{new_size += (column_last_character - *str);}char *new_buffer = (char *)realloc(*buffer, new_size);if (new_buffer == NULL) {perror("Aborting due to");exit(1);}new_buffer[new_size - 1] = '\0';strncpy(new_buffer, *str, new_size - 1);/* buffer contains '\0' */if (new_size == 1){new_size = 0;}*buffer = new_buffer;if (next_column != NULL && *next_column != '\0' &&strchr(seps, *next_column) != NULL){*separator = *next_column++;}*str = (next_column == NULL || *next_column == '\0')? NULL : next_column;return new_size;}bool is_in_string(char *str, char *line){char *aux = strstr(line, str);return (aux == NULL) ? false : true;} int  r30 ()  { TexlerObject * input = (TexlerObject *)calloc(1, sizeof(TexlerObject));if (input == NULL) {perror("Aborting due to");exit(1);}if (open_file("test_file_cases.txt", "r", input, "1"";") == false){free_texlerobject(input);return 1;}input->value.file.n_files = 1;TexlerObject * abc = (TexlerObject *)calloc(1, sizeof(TexlerObject));if (abc == NULL) {perror("Aborting due to");exit(1);}abc->type = TYPE_T_BOOLEAN;abc->value.boolean = 1;TexlerObject * def = (TexlerObject *)calloc(1, sizeof(TexlerObject));if (def == NULL) {perror("Aborting due to");exit(1);}def->type = TYPE_T_BOOLEAN;def->value.boolean = 1;abc->value.boolean = 0;abc->type = TYPE_T_BOOLEAN;memcpy(abc, def, sizeof(TexlerObject));return 0; } int main(const int argc, const char **argv){return r30();}